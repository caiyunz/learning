如果将值分组到一个结构中，并且通过编号对其进行引用，列表就能派上用场了。将学到一种通过名字引用值的数据结构。这种结构类型称为映射。字典是Python中唯一内建的映射类型。字典中的值并没有特殊的顺序，但是都存储在一个特定的键(Key)里。键可以是数字，字符串甚至是元组。
4.1字典的使用
字典这个名称已经给出了有关这个数据结构功能的一些提示:一方面，对于普通的书来说，都是按照从头到尾的顺序进行阅读。如果愿意，也可以快速翻到某一页，这有点像Python的列表。另一方面，现实中的字典及在Python中的字典都进行了构造，从而可以轻松查到某个特定的词语(键),从而找到它的定义(值)。
某些情况下，字典比列表更加适用，比如:
表征游戏键盘的状态，每个键都是由坐标值组成的元组；
存储文件修改次数，用文件名作为键；
数字电话/地址簿
假如有一个人名列表如下:
names=['Alice','Beth','Cecil','Dee-Dee','Earl']
如果要创建一个可以存储这些人的电话号码的小型数据库，应该怎么做呢？一种方法是建立一个新的列表。假设只存储四位的分机电话号码，那么可以得到与下面相似的列表：
numbers=['2341','9102','3158','0142','5551']
建立了这些列表后，可以通过如下方式查找Cecil的电话号码：
numbers[names.index('Cecil')]
>>> names=['Alice','Beth','Cecil','Dee-Dee','Earl']
>>> numbers=['2341','9102','3158','0142','5551']
>>> numbers[names.index('Cecil')]

4.2创建和使用字典
字典可以通过下面的方式创建:
phonebook={'Alice':'2341','Beth':'9102','Cecil':'3258'}
字典由多个键及与其对应的值构成的对组成(我们也把键/值对称为项)。在上例中，名字时键，电话号码是值。每个键和它的值之间用冒号(:)隔开，项之间用逗号(,)隔开，而整个字典是由一对大括号括起来。空字典(不包含任何项)由两个大括号组成，像这样：{}
注意:字典中的键是唯一的(其他类型的映射也是如此),而值并不唯一。

4.2.1 dict函数
可以用dict函数，通过其他映射(比如其他字典)或者(键，值)这样的序列对建立字典。
>>> items=[('name','Gumby'),('age',42)]
>>> d=dict(items)
>>> d
{'age': 42, 'name': 'Gumby'}
dict函数也可以通过关键字参数来创建字典，如下例所示：
>>> d=dict(name='Gumby',age=42)
>>> d
{'age': 42, 'name': 'Gumby'}
这可能是dict函数最有用的功能了，但是还能以映射作为dict函数的参数，以建立其项与映射相同的字典(如果不带任何参数，则dict函数返回一个新的空字典，就像list,tuple以及str等函数一样).如果另一个映射也是字典（毕竟这是唯一内建的映射类型),也可以使用本章稍后讲到的字典方法copy。

4.2.2基本字典操作
字典的基本行为在很多方面与序列(sequence)类似：
len(d)返回d中项(键-值对)的数量;
d[k]返回关联到键k上的值;
d[k]=v将值v关联到键k上；
del d[k]删除键为k的项；
k in d检查d中是否有含有键为k的项
尽管字典和列表有很多特性相同，但也有下面一些重要的区别。
键类型：字典的键不一定为整型数据(但也可能是),也可能是其他不可变类型，比如浮点型(实型),字符串或者元组。
自动添加:即使那个键起初在字典中并不存在，也可以为它分配一个值，这样字典就会建立新的项。而(在不使用append方法或者其他类似操作的情况下)不能将值关联到列表范围之外的索引上。
成员资格：表达式k in d(d为字典)查找的是键，而不是值。表达式vinl(l为列表)则用来查找值，而不是索引。这样看起来好像有些不太一致，但是当习惯以后就会感觉非常自然了。毕竟，如果字典含有指定的键，查找相应的值也就很容易了。

提示：在字典中查找键的成员资格比在列表中检查值的成员资格更高效，数据结构的规模越大，两者的效率差距越明显。
第一点----键可以为任何不可变类型-是字典最强大的地方。第二点也很重要。看看下面的区别：
>>> x=[]
>>> x[42]='Foobar'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: list assignment index out of range
>>> x={}
>>> x[42]='Foobar'
>>> x
{42: 'Foobar'}
>>> 
首先，程序试图将字符串'Foobar'关联到一个空列表的42号位置上-这显然是不可能的，因为这个位置根本不存在。为了将其变为可能，我必须用[None]*43或者其他方式初始化x,而不能仅适用[].但是，下一个例子工作得很好，我将'Foobar'关联到空字典的键42上，没问题!新的项已经添加到字典中，我达到目的了。

4.2.3字典的格式化字符串
已经见过如何使用字符串格式化功能来格式化元组中的所有值。如果使用字典而不是元组来做这个工作，会使字符串格式化更酷一些。在每个转换说明符中的%字符后面，可以加上(用圆括号括起来)键，后面再跟上其他说明元素。
>>> phonebook = {'Beth':'9102','Alice':'2341','Cecil':'3258'}
>>> "Cecil's phone number is %(Cecil)s."% phonebook
"Cecil's phone number is 3258."
除了增加的字符串键之外，转换说明符还是像以前一样工作。当以这种方式使用字典的时候，只要所有给出的键都能在字典中找到，就可以获得任意数量的转换说明符。这类字符串格式化在模板系统中非常有用。
毕竟，如果字典含有指定的键，查找相应的值也就很容易了。

提示：在字典中查找键的成员资格比在列表中检查值的成员资格更高效，数据结构的规模越大，两者的效率差距越明显。
第一点----键可以为任何不可变类型-是字典最强大的地方。第二点也很重要。看看下面的区别：
>>> x=[]
>>> x[42]='Foobar'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: list assignment index out of range
>>> x={}
>>> x[42]='Foobar'
>>> x
{42: 'Foobar'}
>>> 
首先，程序试图将字符串'Foobar'关联到一个空列表的42号位置上-这显然是不可能的，因为这个位置根本不存在。为了将其变为可能，我必须用[None]*43或者其他方式初始化x,而不能仅适用[].但是，下一个例子工作得很好，我将'Foobar'关联到空字典的键42上，没问题!新的项已经添加到字典中，我达到目的了。

4.2.3字典的格式化字符串
已经见过如何使用字符串格式化功能来格式化元组中的所有值。如果使用字典而不是元组来做这个工作，会使字符串格式化更酷一些。在每个转换说明符中的%字符后面，可以加上(用圆括号括起来)键，后面再跟上其他说明元素。
>>> phonebook = {'Beth':'9102','Alice':'2341','Cecil':'3258'}
>>> "Cecil's phone number is %(Cecil)s."% phonebook
"Cecil's phone number is 3258."
除了增加的字符串键之外，转换说明符还是像以前一样工作。当以这种方式使用字典的时候，只要所有给出的键都能在字典中找到，就可以获得任意数量的转换说明符。这类字符串格式化在模板系统中非常有用。
毕竟，如果字典含有指定的键，查找相应的值也就很容易了。

提示：在字典中查找键的成员资格比在列表中检查值的成员资格更高效，数据结构的规模越大，两者的效率差距越明显。
第一点----键可以为任何不可变类型-是字典最强大的地方。第二点也很重要。看看下面的区别：
>>> x=[]
>>> x[42]='Foobar'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: list assignment index out of range
>>> x={}
>>> x[42]='Foobar'
>>> x
{42: 'Foobar'}
>>> 
首先，程序试图将字符串'Foobar'关联到一个空列表的42号位置上-这显然是不可能的，因为这个位置根本不存在。为了将其变为可能，我必须用[None]*43或者其他方式初始化x,而不能仅适用[].但是，下一个例子工作得很好，我将'Foobar'关联到空字典的键42上，没问题!新的项已经添加到字典中，我达到目的了。

4.2.3字典的格式化字符串
已经见过如何使用字符串格式化功能来格式化元组中的所有值。如果使用字典而不是元组来做这个工作，会使字符串格式化更酷一些。在每个转换说明符中的%字符后面，可以加上(用圆括号括起来)键，后面再跟上其他说明元素。
>>> phonebook = {'Beth':'9102','Alice':'2341','Cecil':'3258'}
>>> "Cecil's phone number is %(Cecil)s."% phonebook
"Cecil's phone number is 3258."
除了增加的字符串键之外，转换说明符还是像以前一样工作。当以这种方式使用字典的时候，只要所有给出的键都能在字典中找到，就可以获得任意数量的转换说明符。这类字符串格式化在模板系统中非常有用。
毕竟，如果字典含有指定的键，查找相应的值也就很容易了。

提示：在字典中查找键的成员资格比在列表中检查值的成员资格更高效，数据结构的规模越大，两者的效率差距越明显。
第一点----键可以为任何不可变类型-是字典最强大的地方。第二点也很重要。看看下面的区别：
>>> x=[]
>>> x[42]='Foobar'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: list assignment index out of range
>>> x={}
>>> x[42]='Foobar'
>>> x
{42: 'Foobar'}
>>> 
首先，程序试图将字符串'Foobar'关联到一个空列表的42号位置上-这显然是不可能的，因为这个位置根本不存在。为了将其变为可能，我必须用[None]*43或者其他方式初始化x,而不能仅适用[].但是，下一个例子工作得很好，我将'Foobar'关联到空字典的键42上，没问题!新的项已经添加到字典中，我达到目的了。

4.2.3字典的格式化字符串
已经见过如何使用字符串格式化功能来格式化元组中的所有值。如果使用字典而不是元组来做这个工作，会使字符串格式化更酷一些。在每个转换说明符中的%字符后面，可以加上(用圆括号括起来)键，后面再跟上其他说明元素。
>>> phonebook = {'Beth':'9102','Alice':'2341','Cecil':'3258'}
>>> "Cecil's phone number is %(Cecil)s."% phonebook
"Cecil's phone number is 3258."
除了增加的字符串键之外，转换说明符还是像以前一样工作。当以这种方式使用字典的时候，只要所有给出的键都能在字典中找到，就可以获得任意数量的转换说明符。这类字符串格式化在模板系统中非常有用。
4.2.4字典方法
就想起他内建类型一样，字典也有方法。这些方法非常有用，但是可能不会像是用列表或者字符串方法那样频繁地使用。
1.clear
clear方法清除字典中所有的项。这个是原地操作，所以无返回值(或者说返回None).

2.copy
copy方法返回一个具有相同键-值对的新字典(这个方法实现的浅复制，因为值本身就是相同的，而不是副本)
当在副本中替换值的时候，原始字典不受影响，但是，如果修改了某个值(原地修改，而不是替换),原始的字典也会改变，因为同样的值也存储在原字典中
避免这个问题的一种方法就是使用深复制，复制其所包含所有的值。可以使用copy模块的deepcopy函数来完成操作。
3.fromkeys
fromkeys方法使用给定的键建立新的字典，每个键默认对应的值为None.
4.get 
get方法是个更宽松的访问字典项的方法。一般来说，如果试图访问字典中不存在的项时会出错：
>>> d={}
>>> print d['name']
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyError: 'name'
>>> print d.get('name')
None
可以看到，当使用get访问一个不存在的键时，没有任何异常，而得到了None的值。还可以自定义"默认"值，替换None:
>>> d.get('name','N/A')
'N/A'
>>> 
如果键存在，get用起来就像普通的字典查询一样：
>>> d['name']='Eric'
>>> d.get('name')
'Eric'
>>> 
5.has_key
has_key方法可以检查字典中是否含有给出的键。表达式d.has_key(k)相当于表达式k in d.使用哪种方式很大程度上取决于个人的喜好。
6.items和iteritems
items方法将所有的字典项以列表方式返回，这些列表项中的每一项都来自于(键，值).但是项在返回时并没有特殊的顺序。
> d={'title':'Python Web Site','url':'http://www.python.org','spam':0}
>>> d.items()
[('url', 'http://www.python.org'), ('spam', 0), ('title', 'Python Web Site')]
iteritems方法的作用大致相同，但是会返回一个迭代器对象而不是列表：

>>> it=d.iteritems()
>>> it
<dictionary-itemiterator object at 0x7fca3993a260>
>>> list(it)
[('url', 'http://www.python.org'), ('spam', 0), ('title', 'Python Web Site')]
在很多情况下使用iteritems更高效。
7.keys和iterkeys
keys方法将字典中的键以列表形式返回，而iterkeys则返回针对键的迭代器。
8.pop
pop方法用来获得对应于给定键的值，然后将这个键-值对从字典中移除。
9.popitem
popitem方法类似于list.pop,后者会弹出列表的最后一个元素。但不同的是，popitem弹出随机的项，因为字典并没有"最后的元素"或者其他有关顺序的概念。
尽管popitem和列表的pop方法很类似，但字典中没有与append等价的方法。因为字典是无序的，类似于append的方法是没有任何意义的。
10.setdefault
setdefault方法在某种程度上类似于get方法，就是能够获得与给定键相关联的值，除此之外，setdefault还能在字典中不含有给定键的情况下设定相应的键值。
>>> d.setdefault('name','N/A')
'N/A'
>>> d
{'name': 'N/A'}
>>> d['name']='Gumby'
>>> d.setdefault('name','N/A')
'Gumby'
>>> d
{'name': 'Gumby'}
可以看到，当键不存在的时候，setdefault返回默认值并且相应地更新字典。如果键存在，那么就返回与其对应的值，但不改变字典。默认值是可选的，这点和get一样。如果不设定，会默认使用None.

11.update
update方法可以利用一个字典项更新另外一个字典:
>>> d={
...    'title':'Python Web Site',
...    'url':'http://www.python.org',
...    'changed':'Mar 14 22:09:15 MET 2008'
... }
>>> x={'title':'Python Language Website'}
>>> d.update(x)
>>> d
{'url': 'http://www.python.org', 'changed': 'Mar 14 22:09:15 MET 2008', 'title': 'Python Language Website'}
提供的字典中的项会被添加到旧的字典中，若有相同的键则会进行覆盖。
update方法可以使用与调用dict函数(或者类型构造函数)同样的方式进行调用，这意味着update可以和映射，拥有(键，值)对的队列(或者其他可迭代的对象)以及关键字参数一起调用。
12.values和itervalues
values方法以列表的形式返回字典中的值(itervalues返回值的迭代器)。与返回键的列表不同的是，返回值的列表中可以包含重复的元素：
>>> d={}
>>> d[1]=1
>>> d[2]=2
>>> d[3]=3
>>> d[4]=1
>>> d.values()
[1, 2, 3, 1]

